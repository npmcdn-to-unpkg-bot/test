
// http://blog.csdn.net/fansongy/article/details/6798278
// http://blog.chinaunix.net/uid-27033491-id-3302027.html


一、基本概念

每个结点最多有两棵子树，左子树和右子树，次序不可以颠倒。
性质：
    1、非空二叉树的第n层上至多有 2^(n-1) 个元素。
    2、深度为h的二叉树至多有 2^h-1 个结点。
满二叉树：
    所有终端都在同一层次，且非终端结点的度数为2。
    在满二叉树中若其深度为h，则其所包含的结点数必为2^h-1。
完全二叉树：
    若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，
    第 h 层所有的结点都连续集中在最左边，这就是完全二叉树
           1     |                   1       
         /  \    |                 /  \      
        1    1   |                1    1    
       / \  / \  |               / \    \   
      1  1 1   1 |              1  1     1  --> 不满
     / \ /                    / \ /        
     1 1 1        h          1  1 1        
     完全二叉树                    非完全二叉树


三、二叉树的遍历
    遍历即将树的所有结点访问且仅访问一次。按照根节点位置的不同分为 前序遍历，中序遍历，后序遍历。
        前序遍历：根节点->左子树->右子树
        中序遍历：左子树->根节点->右子树
        后序遍历：左子树->右子树->根节点
    例如：求下面树的三种遍历
                 a
                / \
               b   c
             /  \
            d    f 
            \   /
             e g
    前序遍历：abd ef g c
    中序遍历：debgfac
    后序遍历：edgfbca


1. 二叉搜索树(二叉查找树): Binary Search Tree (BST)
    特点是，小的值在左边，大的值在右边，即
    这样的结构有一个好处是很容易获得最大值(Maximum),最小值(minimum),某元素的前驱(Precursor),某元素的后继(Successor)
    最大值：树的最右节点
    最小值：树的最左节点
    某元素前驱：左子树的最右
    某元素的后继：右子树的最左
       x              2
      / \            / \
    <x   >x         1   7
                       / \
                      4   8
                     / \
                    3   6
                       /
                      5
    二叉搜索树的基本操作包括searching、traversal、insertion以及deletion
    1) searching
        时间复杂度为O(h)，h为树的高度
    2) traversal
        由于小的节点在左边，大的节点在右边，因此使用中序(in-order)遍历可以方便的得到一个sorted list
        时间复杂度为O(n)，n为树的总结点数
    3) insertion
        时间复杂度为O(h)，h为树的高度
    4) deletion
        在删除节点时有三种情况
        1. 要删除的节点为叶节点 (5)
        　　  那么直接删除即可
        2. 要删除的节点有一个子节点 (6)
        　　  那么删除掉该节点，并用其唯一的子节点代替自己的位置即可
        3. 要删除的节点有两个子节点 (4) or (7)
            那么首先要找到该节点的右子树的最小值节点k，然后将该k替换掉待删除节点
            最坏情况下，时间复杂度为O(h)+指针的移动开销
    进阶
        由上可知，二叉搜索树的dictionary operation（包括search、insertion、deletion）的时间复杂度均与O(h)相关，
        h为树的高度(log n)，如果按照上述的insertion方法构建树，那么构建出来的树的形状各异，特别是当输入序列有序时，更会退化到链表的程度.
                                                                                        ~~~~~~            ~~~~  
        所以，如果能用某种方法，将树的高度降低到最小，那么其dictionary operation的时间开销均可以降低，不过相对而言构建树的开销将增大.
        为了降低二叉搜索树的高度而提出了平衡二叉树(Balanced Binary Tree)的概念.它要求左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树.
        这样就可以将搜索树的高度尽量减小.常用算法有红黑树、AVL、Treap、伸展树等

2. 